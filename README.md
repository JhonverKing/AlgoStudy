참여인원 4
> 잡부 : https://github.com/lordchiwoo/algo_programmers  
> 강서 : https://github.com/mertyn88/algorithm  
> 가니 : https://github.com/kwan1989/algorithm_Programmers

진행방법
> 프로그래머스나 기타 알고리즘 문제를 각자의 방법으로 해결하고 각자 깃허브에 업로드 함.  
> 이후 디스코드 화면 공유로 문제 해결 과정에 대한 리뷰를 진행 함. 

---

## 순위
### 문제 및 풀이
[Programmers](https://programmers.co.kr/learn/courses/30/lessons/49191)  
[Git Solution](https://github.com/JhonverKing/AlgoStudy/blob/main/BoxerRank/src/Main.java)  

<details markdown="1">
  <summary>내용 보기</summary>

### 문제내용
````
n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다.
권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다.
심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다.
하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.

선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때
정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.

 - 선수의 수는 1명 이상 100명 이하입니다.
 - 경기 결과는 1개 이상 4,500개 이하입니다.
 - results 배열 각 행 [A, B]는 A 선수가 B 선수를 이겼다는 의미입니다.
 - 모든 경기 결과에는 모순이 없습니다.  
````
|n|results|return|  
|---|---|---|  
|5|[[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]]|2|  

### 풀이과정
##### 초기구상
1. 각 노드가 이긴 목록을 담은 HashMap 만들기  
2. 각 노드가 패배한 목록을 담은 HashMap 만들기  
3. 두 HashMap에서 각 노드의 사이즈를 더해서 n-1이면 answer++  

##### 진행하며 수정된 내용  
 - 각 노드가 배배한 목록을 담은 HashMap은 필요가 없어서 빼고함.  
 - 이긴 목록에서 패배한 목록을 찾을 수 있기 때문임.   
 - HashMap에 ArrayList를 담았다가 중복체크하는 부분에서 오래걸려서 실패함  
 - 그래서 ArrayList를 HashSet으로 바꿔서 도전 

##### 최종형태
1. `winnerHashMap` 초기 Key를 생성해둔다 - 나중에 소스안에서 있는지 비교해서 만드는거는 귀찮기때문
2. `dfs`로 해당 노드가 이기는 대상들을 찾아서 winnerHashMap에 넣는다. 이 때 HashSet으로 중복은 허용하지 않는다.
3. 더이상 이기는 대상이 없는 노드는 visited[target] = 1로 방문 완료로 처리해둔다.
4. 노드가 이기는 대상이 방문이 완료된 노드라면 대상을 Key값으로 목록을 불러와서 현재 노드에 값들을 추가해준다.
5. 그렇게 완성된 winnerHashMap에서 각 노드의 사이즈와 각 노드를 가지고 있는 목록을 카운트해서 합한 값을 배열에 저장한다.
6. 배열의 값이 n-1과 같은 노드는 answer++

##### 실행결과 1차) ArrayList를 담은 HashMap - 실패
    테스트 1 〉   통과 (0.11ms, 52.2MB)  
    테스트 2 〉   통과 (0.14ms, 51.9MB)  
    테스트 3 〉   실패 (0.57ms, 52.6MB)  
    테스트 4 〉   실패 (런타임 에러)  
    테스트 5 〉   실패 (50.70ms, 59.9MB)  
    테스트 6 〉   실패 (317.93ms, 125MB)  
    테스트 7 〉   실패 (메모리 초과)  
    테스트 8 〉   실패 (메모리 초과)  
    테스트 9 〉   실패 (메모리 초과)  
    테스트 10 〉   실패 (메모리 초과)  

##### 실행결과 2차) HashSet을 담은 HashMap - 성공
    테스트 1 〉	통과 (8.66ms, 53.2MB)  
    테스트 2 〉	통과 (8.64ms, 52.9MB)  
    테스트 3 〉	통과 (8.58ms, 53.1MB)  
    테스트 4 〉	통과 (9.53ms, 52.9MB)  
    테스트 5 〉	통과 (10.79ms, 52.7MB)  
    테스트 6 〉	통과 (11.87ms, 55.1MB)  
    테스트 7 〉	통과 (30.32ms, 53.9MB)  
    테스트 8 〉	통과 (36.34ms, 58.7MB)  
    테스트 9 〉	통과 (45.96ms, 57.9MB)  
    테스트 10 〉	통과 (44.41ms, 56.2MB)  


</details>


## 가장 먼 노드 (2021.06.28)  
### 문제 및 풀이  
[Programmers](https://programmers.co.kr/learn/courses/30/lessons/49189)  
[Git Solution](https://github.com/JhonverKing/AlgoStudy/blob/main/FarthestNode/src/Main.java)  
<details markdown="1">
  <summary>내용 보기</summary>
  
### 문제내용
````
n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다.
1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다.
가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다.
노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때,
1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요.

 - 노드의 개수 n은 2 이상 20,000 이하입니다.
 - 간선은 양방향이며 총 1개 이상 50,000개 이하의 간선이 있습니다.
 - vertex 배열 각 행 [a, b]는 a번 노드와 b번 노드 사이에 간선이 있다는 의미입니다.
````
|n|vertex|return|
|---|---|---|
|6|[[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]|3|

### 풀이과정
##### 초기구상
1. bfs로 1번부터 출발해서 갈 수 있는 인접노드를 찾으면서 nextQue를 만들고
2. 현재큐에 nextQue의 값들을 넣고 다시 다음 nextQue를 만든다
3. 더이상 인접한 노드를 찾을 수 없을때 마지막 큐의 사이즈가 정답이다!

##### 진행하며 수정된 내용 
 - 큐 돌리면서 다음 인접노드 리스트를 만드니까 성능문제로 탈락
 - 노드별 인접한 노드 리스트를 담은 ``adjNodeList``를 미리 만들기로 함

##### 최종형태
1. ``adjNodeList`` 인접노드를 미리 담아둠
2. ``bfs`` 구현
3. curQue - 현재 depth에서 방문할 노드 / nextQue - 다음 depth에서 방문할 노드
4. ``visitedEdge[] `` 방문체크
5. 마지막 큐의 사이즈가 정답

##### 실행결과
    테스트 1 〉	통과 (2.76ms, 52.4MB)
    테스트 2 〉	통과 (3.07ms, 52.3MB)
    테스트 3 〉	통과 (6.76ms, 53.2MB)
    테스트 4 〉	통과 (7.21ms, 52.9MB)
    테스트 5 〉	통과 (16.94ms, 54.7MB)
    테스트 6 〉	통과 (14.63ms, 55.5MB)
    테스트 7 〉	통과 (86.35ms, 76.2MB)
    테스트 8 〉	통과 (155.73ms, 78.4MB)
    테스트 9 〉	통과 (123.51ms, 78.2MB)

</details>


## 단어변환 (2021.06.21)  
### 문제 및 풀이  
[Programmers](https://programmers.co.kr/learn/courses/30/lessons/43163)  
[Git Solution](https://github.com/JhonverKing/AlgoStudy/blob/main/WordConversion/src/Main.java)  
<details markdown="1">
  <summary>내용 보기</summary>

### 문제내용
````
두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 
아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다.

    1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다.
    2. words에 있는 단어로만 변환할 수 있습니다.
    예를 들어 begin이 "hit", target가 "cog", words가 ["hot","dot","dog","lot","log","cog"]라면
    "hit" -> "hot" -> "dot" -> "dog" -> "cog"와 같이 4단계를 거쳐 변환할 수 있습니다.

두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때,
최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요.

 - 각 단어는 알파벳 소문자로만 이루어져 있습니다.
 - 각 단어의 길이는 3 이상 10 이하이며 모든 단어의 길이는 같습니다.
 - words에는 3개 이상 50개 이하의 단어가 있으며 중복되는 단어는 없습니다.
 - begin과 target은 같지 않습니다.
 - 변환할 수 없는 경우에는 0를 return 합니다.
````
|begin|target|words|return|
|---|---|---|---|
|"hit"|"cog"|["hot", "dot", "dog", "lot", "log", "cog"]|4|
|"hit"|"cog"|["hot", "dot", "dog", "lot", "log"]|0|

### 풀이과정
##### 초기구상
1. 단어리스트 반복문 돌면서 현재 단어로부터 바꿀 수 있는 단어인지 찾음
2. 바꿀수 있는 단어 nextQue에 넣음
3. bfs 방식으로 각 단어들의 바꿀수있는 다음 노드 리스트를 생성해서
4. 발견시 depth를 반환하면 정답

##### 진행하며 수정된 내용 
 - bfs, dfs 두가지 방식으로 

##### 최종형태
1. bfs 방식
  1.1. 단어리스트 반복문 돌면서 현재 단어로부터 바꿀 수 있는 단어인지 찾음
  1.2. 변경 가능한 단어는 방문표시 하고 다음 방문할 큐에 추가
  1.3. 현재 큐가 비어있을때 다음 방문할 큐가 있다면 방문할 큐를 현재 큐에 넣고 depth를 1 증가한다.
  1.4. 변경 가능한 단어중 target이 있다면 depth+1을 결과로 리턴
  1.5. 발견시 depth를 반환하면 정답
 
2. dfs 방식
  2.1. 방문배열을 노드별로 관리하기 위해 새로운 배열을 생성하여 초기값을 클론으로 할당
  2.2. 목표 단어와 일치할 경우 노드의 깊이를 반환한다.
  2.3. 반복 돌면서 변경 가능한 단어는 방문표시 하고 방문(재귀)
  2.4. 방문한 노드에서 목표단어 까지의 depth를 리턴받아서 가장 작은 값을 result에 담아서 최소값을 유지한다.

##### 실행결과 - BFS
    테스트 1 〉	통과 (0.16ms, 52.3MB)
    테스트 2 〉	통과 (0.19ms, 53MB)
    테스트 3 〉	통과 (1.24ms, 53.2MB)
    테스트 4 〉	통과 (0.12ms, 52.6MB)
    테스트 5 〉	통과 (0.13ms, 53MB)
    
##### 실행결과 - DFS
    테스트 1 〉	통과 (0.03ms, 52.4MB)
    테스트 2 〉	통과 (0.15ms, 53.3MB)
    테스트 3 〉	통과 (0.92ms, 53.1MB)
    테스트 4 〉	통과 (0.04ms, 52.8MB)
    테스트 5 〉	통과 (0.04ms, 52.7MB)

</details>


## 네트워크 (2021.06.14)  
### 문제 및 풀이
[Programmers](https://programmers.co.kr/learn/courses/30/lessons/43162)  
[Git Solution](https://github.com/JhonverKing/AlgoStudy/blob/main/Network/src/Main.java)  
<details markdown="1">
  <summary>내용 보기</summary>

### 문제내용
````
네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고,
컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다.
따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다.
컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.
        
 - 컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다.
 - 각 컴퓨터는 0부터 n-1인 정수로 표현합니다.
 - i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다.
 - computer[i][i]는 항상 1입니다.
````
|n|computers|return|
|---|---|---|
|3|[[1, 1, 0], [1, 1, 0], [0, 0, 1]]|2|
|3|[[1, 1, 0], [1, 1, 1], [0, 1, 1]]|1|

### 풀이과정
##### 초기구상
1. bfs로 돌면서 다음 방문할 노드를 찾고
2. 방문체크하고
3. 더이상 방문할곳이 없으면 리턴하고 cnt + 1
4. 이렇게 노드 수만큼 실행하면 될거같다

##### 진행하며 수정된 내용 
 - 처음에는 computers에 값을 2로 수정해서 방문체크를 진행했으나
   메서드 내부에서 coms[depth][depth] == 2 이렇게 비교하는게 직관적이지 않고
   computers의 값을 변경했기 때문에 다시 활용할수 없음,
   computers를 원본으로 유지하려면 결국 2차원 배열에 대한 Deep Copy를 해야함
 - 방문체크용 visitedArray를 따로 생성해서 사용하기로 함

##### 최종형태
1. 노드수만큼 반복문 안에서 dfs 메서드 실행
2. 방문체크하면서 인접노드가 없어지면 1개의 네트워크로 cnt++ 처리

##### 실행결과
    테스트 1 〉	통과 (0.03ms, 53.3MB)
    테스트 2 〉	통과 (0.02ms, 52.5MB)
    테스트 3 〉	통과 (0.05ms, 52.3MB)
    테스트 4 〉	통과 (0.06ms, 52.1MB)
    테스트 5 〉	통과 (0.02ms, 53MB)
    테스트 6 〉	통과 (0.12ms, 52MB)
    테스트 7 〉	통과 (0.03ms, 52.3MB)
    테스트 8 〉	통과 (0.10ms, 52.6MB)
    테스트 9 〉	통과 (0.06ms, 53.7MB)
    테스트 10 〉	통과 (0.06ms, 52.9MB)
    테스트 11 〉	통과 (0.35ms, 53.4MB)
    테스트 12 〉	통과 (0.27ms, 53.1MB)
    테스트 13 〉	통과 (0.24ms, 53.1MB)

</details>


## 타겟넘버 (2021.06.07)  
### 문제 및 풀이
[Programmers](https://programmers.co.kr/learn/courses/30/lessons/43165)  
[Git Solution](https://github.com/JhonverKing/AlgoStudy/blob/main/TargetNumber/src/Main.java)  
<details markdown="1">
  <summary>내용 보기</summary>

### 문제내용
````
n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다.
예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.

    -1+1+1+1+1 = 3
    +1-1+1+1+1 = 3
    +1+1-1+1+1 = 3
    +1+1+1-1+1 = 3
    +1+1+1+1-1 = 3
    
사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때
숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.

 - 주어지는 숫자의 개수는 2개 이상 20개 이하입니다.
 - 각 숫자는 1 이상 50 이하인 자연수입니다.
 - 타겟 넘버는 1 이상 1000 이하인 자연수입니다.
````
|numbers|target|return|
|---|---|---|
|[1, 1, 1, 1, 1]|3|5|

### 풀이과정
##### 초기구상
1. 이 문제는 스스로 풀지않고 정답을 봄

##### 최종형태
1. 재귀 안에서 플러스의 경우와 마이너스의 경우를 모두 실행하여 sum을 구함
2. depth가 주어진 숫자의 수와 같아지면
3. sum이 target과 같은지 비교하여 맞으면 1을 리턴함
4. 각 재귀의 모든 리턴을 더하면 정답 알 수 있음.  

##### 실행결과
    테스트 1 〉	통과 (15.82ms, 31.8MB)
    테스트 2 〉	통과 (14.93ms, 31.7MB)
    테스트 3 〉	통과 (0.33ms, 30.2MB)
    테스트 4 〉	통과 (0.88ms, 30MB)
    테스트 5 〉	통과 (2.96ms, 32MB)
    테스트 6 〉	통과 (0.58ms, 30.1MB)
    테스트 7 〉	통과 (0.33ms, 30.1MB)
    테스트 8 〉	통과 (2.45ms, 32MB)
    
</details>

